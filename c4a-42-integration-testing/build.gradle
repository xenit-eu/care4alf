import com.github.dynamicextensionsalfresco.gradle.tasks.InstallBundle
import com.github.dynamicextensionsalfresco.gradle.configuration.BaseConfig
import groovyx.net.http.RESTClient

apply plugin: 'xenit-applyamps'

sourceCompatibility = 1.7
targetCompatibility = 1.7

configurations {
    integrationJar
    compileOnly.extendsFrom(integrationJar)
}

ext {
    dockerAlfrescoVersion = "4.2.8"
    dockerAlfrescoVersionLabel = "4.2.8"
}

dependencies {
    compileOnly(project(":care4alf"))
    integrationJar(group: 'eu.xenit.testing', name: 'integration-testing', version: '1.0')
    compile(group: 'com.fasterxml.jackson.core', name: 'jackson-core', version: '2.3.2')
    compile(group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.3.2')
    compile group: 'io.rest-assured', name: 'rest-assured', version: '3.0.1'
    compile group: 'io.rest-assured', name: 'json-path', version: '3.0.1'
    compile group: 'io.rest-assured', name: 'rest-assured-common', version: '3.0.1'
    compile group: 'org.mockito', name: 'mockito-core', version: '1.10.19'
    compile group: 'com.google.guava', name: 'guava', version: '19.0'
}
// These dependencies are for the docker build
dependencies {
    baseAlfrescoWar "org.alfresco:alfresco:${dockerAlfrescoVersionLabel}@war"
    alfrescoAmp "eu.xenit:alfresco-dynamic-extensions-repo:${deVersion}@amp"
    alfrescoAmp project(path: ':care4alf', configuration: 'ampArtifact')
}

bundle {
    instruction 'Export-Package', 'eu.xenit.care4alfintegration.*'
    instruction 'Alfresco-Dynamic-Extension', 'true'
    instruction 'Include-Resource', includeResource(configurations.compile)
    instruction 'Bundle-ClassPath', bundleClassPath(configurations.compile)
    // These are imported by rest-assured but not declared in the manifest
    instruction 'Import-Package', '!com.github.scribejava.*,!com.google.gson,' +
            // These are the fault of groovy
            '!org.apache.commons.cli,!org.apache.ivy.*,!org.fusesource.jansi,' +
            // This is the fault of commons-logging
            '!org.apache.log,' +
            // This is the fault of mockito
            '!org.apache.tools.ant.*,!org.junit.runners.*,!org.junit.runner.notification.*,' +
            '!org.junit.internal.runners.*,!org.junit.rules.*,!org.mockito.asm.signature,*'
    // Rewrite this, otherwise it thinks it *needs* java 1.8, while alf4.2 only has 1.7
    // I don't know *why* it thinks this, otherwise I'd fix it in the correct place
    //instruction 'Require-Capability', 'sgi.ee;filter:="(&(osgi.ee=JavaSE)(version=1.7))'
}

project.extensions.add("alfrescoDynamicExtensions", new BaseConfig())

dockerAlfresco {
    baseImage = "hub.xenit.eu/alfresco-enterprise:${dockerAlfrescoVersion}"
    leanImage=true
    dockerBuild {
        repository = 'hub.xenit.eu/care4alf-alfresco-42'
    }
}

composeUp {
    doLast {
        def serviceInfo = servicesInfos.get("alfresco-core")
        String url  = "http://${serviceInfo.getHost()}:${serviceInfo.getPort()}/alfresco/s/dynamic-extensions/"
        println "Sleeping for startup"
        for (int i = 0; ; i++) {
            def client = new RESTClient()
            client.uri = url
            client.auth.basic("admin", "admin")
            try {
                System.out.println("Poll $url")
                def response = client.get([:])
                if (response.isSuccess()) {
                    System.out.println("Ready: " + response.getStatusLine())
                    break
                } else {
                    System.out.println(response.getStatusLine());
                }
            } catch (IOException e) {
                if (i == 20) {
                    throw e
                }
                System.out.println("IO Error: " + e.getMessage())
                println "zzzz"
                Thread.sleep(5000)
            }
        }
        println("Sleeping another 25s...")
        Thread.sleep(25000) //Give the boy a little extra time otherwise kaboom kaboom
    }
}

def composeUpTask = project.tasks.getByName("composeUp")

task configureDE {
    dependsOn composeUpTask
    doLast {
        def serviceInfo = composeUpTask.servicesInfos.get("alfresco-core")
        def port = serviceInfo.getPort()
        def host = serviceInfo.getHost()
        alfrescoDynamicExtensions.repository.endpoint.port = port
        alfrescoDynamicExtensions.repository.endpoint.host = host
    }
}

task installIntegrationJar(type: InstallBundle) {
    dependsOn configureDE
    configuration = configurations.integrationJar {transitive=false}
}

task installTestsOnDocker(type: InstallBundle) {
    dependsOn installIntegrationJar
    dependsOn jar
}

// Build a docker image, do a compose up, install the tests, run them
// Gets configuration information from the running docker
task integrationTest(type: Test) {
    dependsOn installTestsOnDocker
    testClassesDirs = sourceSets.main.output.classesDirs
    classpath = sourceSets.main.runtimeClasspath
    classpath += sourceSets.main.compileClasspath
    doFirst {
        def serviceInfo = composeUpTask.servicesInfos.get("alfresco-core")
        def port = serviceInfo.getPort()
        def host = serviceInfo.getHost()
        systemProperty('alfresco.url', "http://admin:admin@$host:$port/alfresco")
        systemProperty('protocol', 'http')
        systemProperty('host', host)
        systemProperty('port', port)
    }

    //After the tests, the docker setup should be stopped
    finalizedBy(composeDown)
}

// Like above but assuming a docker container is already running
task integrationTestLocal(type: Test) {
    testClassesDirs = sourceSets.main.output.classesDirs
    classpath = sourceSets.main.runtimeClasspath
    classpath += sourceSets.main.compileClasspath
    def host = project.hasProperty('host') ? project.host : 'localhost'
    def port = project.hasProperty('port') ? project.port : '8000'
    def protocol = project.hasProperty('protocol') ? project.protocol : 'http'
    systemProperty('alfresco.url', "$protocol://admin:admin@$host:$port/alfresco")
    systemProperty('protocol', protocol)
    systemProperty('host', host)
    systemProperty('port', port)

    outputs.upToDateWhen {false}
}
